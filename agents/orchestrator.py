"""
Agent Orchestrator implementation using LangGraph.
Manages communication and coordination between specialized agents.
"""

import logging
from typing import Dict, Any, List, TypeVar, Annotated
from datetime import datetime
from langgraph.graph import Graph
from langgraph.prebuilt.tools import ToolExecutor
from .primary_counselor import PrimaryCounselorAgent
from .strategic_planning import StrategicPlanningAgent
from .base import AgentError
import json

logger = logging.getLogger(__name__)

# Define state type for graph
StateType = Dict[str, Any]

class AgentMessage:
    """Message format for inter-agent communication"""
    def __init__(self, sender: str, content: Dict[str, Any], metadata: Dict[str, Any] = None):
        self.sender = sender
        self.content = content
        self.metadata = metadata or {}
        self.timestamp = datetime.now()

    def to_dict(self) -> Dict[str, Any]:
        return {
            "sender": self.sender,
            "content": self.content,
            "metadata": self.metadata,
            "timestamp": self.timestamp.isoformat()
        }

class AgentOrchestrator:
    """Manages the multi-agent system using LangGraph"""

    def __init__(self):
        # Initialize agents
        self.agents = {
            "counselor": PrimaryCounselorAgent(),
            "strategic": StrategicPlanningAgent(),
        }

        # Initialize LangGraph
        self.graph = Graph()

        # Add nodes for each agent
        for agent_name, agent in self.agents.items():
            self.graph.add_node(agent_name, self._create_agent_node(agent))

        # Define edges (agent communication paths)
        self._setup_communication_paths()

    def _create_agent_node(self, agent):
        """Create a node function for an agent"""
        def node_fn(state: StateType) -> StateType:
            try:
                # Process the state with the agent
                response = agent.get_response(
                    state['messages'][-1]["content"]["message"],
                    state['messages'][-1]["metadata"].get("context")
                )

                # Update state with new message
                state['messages'].append(
                    AgentMessage(
                        sender=agent.__class__.__name__,
                        content={"response": response},
                        metadata={"timestamp": datetime.now().isoformat()}
                    ).to_dict()
                )

                return state
            except Exception as e:
                logger.error(f"Error in agent {agent.__class__.__name__}: {str(e)}")
                state['messages'].append(
                    AgentMessage(
                        sender=agent.__class__.__name__,
                        content={"error": str(e)},
                        metadata={"timestamp": datetime.now().isoformat()}
                    ).to_dict()
                )
                return state
        return node_fn

    def _setup_communication_paths(self):
        """Setup the communication paths between agents"""
        # Define the channel for agent communication
        self.graph.add_edge("counselor", "strategic")

    async def process_message(self, message: str, user_id: int) -> str:
        """Process a user message through the agent system"""
        try:
            # Get initial context
            context = await self.agents["counselor"].get_context(user_id)

            # Create initial state
            initial_state = {
                "messages": [
                    AgentMessage(
                        sender="user",
                        content={"message": message},
                        metadata={"context": context}
                    ).to_dict()
                ],
                "current_agent": "counselor",
                "user_id": user_id
            }

            # Process through graph
            final_state = await self.graph.arun(initial_state)

            # Extract final response
            for msg in reversed(final_state["messages"]):
                if "response" in msg["content"]:
                    return msg["content"]["response"]

            raise AgentError("No response generated by agents")

        except Exception as e:
            logger.error(f"Error in message processing: {str(e)}")
            raise AgentError("Failed to process message through agent system")

    def add_agent(self, name: str, agent: Any) -> None:
        """Add a new agent to the system"""
        try:
            self.agents[name] = agent
            self.graph.add_node(name, self._create_agent_node(agent))
            logger.info(f"Added new agent: {name}")
        except Exception as e:
            logger.error(f"Error adding agent {name}: {str(e)}")
            raise AgentError(f"Failed to add agent: {name}")

    def remove_agent(self, name: str) -> None:
        """Remove an agent from the system"""
        try:
            if name in self.agents:
                del self.agents[name]
                # Note: Current version of langgraph doesn't support node removal
                # We'll just log it
                logger.info(f"Removed agent: {name}")
        except Exception as e:
            logger.error(f"Error removing agent {name}: {str(e)}")
            raise AgentError(f"Failed to remove agent: {name}")

    def get_agent_status(self) -> Dict[str, str]:
        """Get status of all agents in the system"""
        return {
            name: "active" for name in self.agents.keys()
        }